<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sketches/rayCasting/components/caster.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sketches/rayCasting/components/caster.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Caster
 * @author Adam Evans
 */

// P5 library imports
import { Vector } from "p5"
// Local component imports
import Ray from "./ray"

export default class Caster {
  static maxRays = 720
  static maxAngle = 2 * Math.PI / Caster.maxRays
  static maxSpeed = 2

  /**
   * Creates a caster
   * 
   * @param {Vector} position Starting position for caster
   * @param {Number} size Size of caster
   * @param {Number} viewDistance View distance of caster
   */
  constructor(position, size, viewDistance) {
    this.position = position.copy()
    this.size = size

    this.rays = []

    for (let i = 0; i &lt; Caster.maxRays; i++) {
      const angle = Caster.maxAngle * i
      this.rays[i] = new Ray(this.position, angle, viewDistance)
    }
  }

  /**
   * Repositions the caster to the given position
   * 
   * @param {Vector} position New position for caster 
   */
  reposition(position) {
    this.position = position.copy()
    for (const ray of this.rays) ray.reposition(this.position)
  }

  /**
   * Casts rays and checks for ray-boundary intersections
   * 
   * @param {p5} sketch The p5.js sketch
   */
  cast(sketch) {
    for (const ray of this.rays) {
      ray.reset()
      for (const box of [sketch.world, ...sketch.world.obstacles]) {
        for (const boundary of box.boundaries) {
          const { x1, y1, x2, y2 } = boundary.points
          ray.calcIntersection(x1, y1, x2, y2)
        }
      }
    }
  }

  /**
   * Checks whether a move will cause a collision with world boundaries/obstacles
   * 
   * @param {Vector} move The proposed move to be made
   * @param {World} world The world within which to move
   * @returns {Boolean} True if move is valid
   */
  isValidMove(move, world) {
    const proposal = { position: Vector.add(this.position, move), size: this.size }
    if (!world.contains(proposal)) return false
    for (const box of world.obstacles) {
      if (box.contains(proposal)) return false
    }
    return true
  }

  /**
   * Moves the caster based on keys pressed
   * 
   * @param {p5} sketch The p5.js sketch
   */
  move(sketch) {
    const move = sketch.createVector()
    if (sketch.keyIsDown(87)) { // W
      move.add(0, -1)
      if (!this.isValidMove(move, sketch.world)) move.add(0, +1)
    }
    if (sketch.keyIsDown(65)) { // A
      move.add(-1, 0)
      if (!this.isValidMove(move, sketch.world)) move.add(+1, 0)
    }
    if (sketch.keyIsDown(83)) { // S
      move.add(0, +1)
      if (!this.isValidMove(move, sketch.world)) move.add(0, -1)
    }
    if (sketch.keyIsDown(68)) { // D
      move.add(+1, 0)
      if (!this.isValidMove(move, sketch.world)) move.add(-1, 0)
    }

    const fullMove = move.copy().setMag(Caster.maxSpeed)
    if (this.isValidMove(fullMove, sketch.world)) move.setMag(Caster.maxSpeed)
    this.position.add(move)

    for (const ray of this.rays) ray.reposition(this.position)
  }

  /**
   * Draws the caster to the given sketch
   * 
   * @param {p5} sketch The p5.js sketch
   */
  draw(sketch) {
    sketch.push()

    const { x, y } = this.position
    for (const ray of this.rays) ray.draw(sketch)

    sketch.fill([237, 34, 100])
    sketch.noStroke()
    sketch.ellipse(x, y, this.size)

    sketch.pop()
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-Boundary.html">Boundary</a></li><li><a href="module-Box.html">Box</a></li><li><a href="module-BubbleSort.html">BubbleSort</a></li><li><a href="module-Caster.html">Caster</a></li><li><a href="module-HeapSort.html">HeapSort</a></li><li><a href="module-Home.html">Home</a></li><li><a href="module-InsertionSort.html">InsertionSort</a></li><li><a href="module-List.html">List</a></li><li><a href="module-MergeSort.html">MergeSort</a></li><li><a href="module-NavBar.html">NavBar</a></li><li><a href="module-Ray.html">Ray</a></li><li><a href="module-RayCasting.html">RayCasting</a></li><li><a href="module-SelectionSort.html">SelectionSort</a></li><li><a href="module-Sketch.html">Sketch</a></li><li><a href="module-sortingAlgorithms.html">sortingAlgorithms</a></li><li><a href="module-World.html">World</a></li></ul><h3>Classes</h3><ul><li><a href="module-Boundary.html">Boundary</a></li><li><a href="module-Box.html">Box</a></li><li><a href="module-BubbleSort.html">BubbleSort</a></li><li><a href="module-Caster.html">Caster</a></li><li><a href="module-HeapSort.html">HeapSort</a></li><li><a href="module-HeapSort-MaxHeap.html">MaxHeap</a></li><li><a href="module-InsertionSort.html">InsertionSort</a></li><li><a href="module-List.html">List</a></li><li><a href="module-MergeSort.html">MergeSort</a></li><li><a href="module-Ray.html">Ray</a></li><li><a href="module-SelectionSort.html">SelectionSort</a></li><li><a href="module-World.html">World</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Thu Jan 13 2022 18:24:37 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
